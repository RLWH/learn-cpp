# Basics of C++

This folder of codes are the exercises from the LinkedIn Course [Learning C++](https://www.linkedin.com/learning/learning-c-plus-plus-22993675/constants?autoSkip=true&resume=false&u=2057564).

# Running the codes

All C++ files are individual files with their own `main()` entrypoint. You can compile the `*.cpp` file and run the code on your own.

# Directories
- [Data Types](./1.%20Data%20Types/)
- [Structure and Class](./2.%20Structure%20and%20Classes/)

# Some important C++ concepts

C++ is a compiled language. Source code needs to be compiled into an executable file.

Here is the compilation toolchain. A compiler toolchain is a pipeline of software tools that convert source code into executable file.
![C++ Toolchain](./images/C++%20Toolchain.png)

## How does the compiler work?

Here is how all the toolkit works together.
![C++ How does a compiler work](./images/C++-How%20does%20a%20compiler%20work.png)
-   **Compiler**: Compile C++ source file into Assembly File
-   **Assembler**: Generate the object file, which provides the machine code of part of the executable
-   **Linker**: Link all the object file together and generate the Executable Binary.

**Note**: Object file is almost executable, but it may contain just pieces of the code we want to use in the final executable. The job of the linker is to link all the object files that we need and produce the executable binary.

## Not every process start from the source file

As we see from the diagram **Case #2** and **Case #3**, we could either start from writing the assembly file, or we just need to load the libraries that are already compiled.

It is common to load compiled libraries file that we don't need to get access to the source code. Let the Linker do the work.

However, for our scope, we only need to focus on **Case #1** - How to build from C++ source file into executable file.

## Case #1 - C++ Source code comprises of implementation and header files

In C++, usually the source code is comprised by two types of files

-   Header files contain class definitions and function declarations
-   Implementation files contain executable code
-   Implementation files must include their header files
-   Your code should only include the header files, not the implementation files
-   All implementation files must be compiled

We will convert the [class example](./2.%20Structure%20and%20Classes/class.cpp) into [cow.cpp]() and [cow.h]()

# Building the files in VSCode
To build all the relevant files together, we can use the build task in VSCode. However, we need to make sure there is only one `main()` entry function within all the `*.cpp` files within the folder. See [cow_demo](./2.%20Structure%20and%20Classes/cow_demo/) for example. 

This is the following task configuration in `task.json` to build the whole folder. 

```{json}
{
    "type": "cppbuild",
    "label": "C/C++: g++ build active file folder",
    "command": "/usr/bin/g++",
    "args": [
        "-fdiagnostics-color=always",
        "-g",
        "-std=c++23",
        "*.cpp",
        "-o",
        "${fileDirname}/${fileBasenameNoExtension}"
    ],
    "options": {
        "cwd": "${fileDirname}"
    },
    "problemMatcher": ["$gcc"],
    "group": {
        "kind": "build",
        "isDefault": true
    },
    "detail": "Task generated by Debugger."
}
```
